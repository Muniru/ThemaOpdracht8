plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.02)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.06)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.005)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.07)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
reticulate::repl_python()
# Using Reticulate library
rate = lambda Y : (Y + 10) * .9
value = 0
previous = 0
for n in range(30):
print(f"{n}\tValue:{value} \tPrevious:{previous}")
previous = value
value = round(rate(value))
quit
knitr::opts_chunk$set(echo = TRUE)
quit
library(reticulate)
library(deSolve)
reticulate::repl_python()
# Using Reticulate library
rate = lambda Y : (Y + 10) * .9
value = 0
previous = 0
for n in range(30):
print(f"{n}\tValue:{value} \tPrevious:{previous}")
previous = value
value = round(rate(value))
quit
# Using the deSolve library
quit
parameters <- c(addVolume = 10, pV = 0.1)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- addVolume - pV * (y + addVolume)
return(list(c(dY)))
}
)
}
#initial state
state <- c(Volume = 0)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.0)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(addVolume = 10, pV = 0.075)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- addVolume - pV * (y + addVolume)
return(list(c(dY)))
}
)
}
#initial state
state <- c(Volume = 0)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(addVolume = 10, pV = 0.125)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- addVolume - pV * (y + addVolume)
return(list(c(dY)))
}
)
}
#initial state
state <- c(Volume = 0)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.075)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.055)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.08)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.085)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.089)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.086)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.0875)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.086)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.085)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.084)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.082)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 10, r = 0.082)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = .1)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = 1)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = .4)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = .0001)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = .1)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 16, r = 0)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
# Using the deSolve library
parameters <- c(m = 3, r = .1)
# define model
volume <- function(t,y,parms){
with(as.list(c(parms)),{
dY <- m - r * y
return(list(c(dY)))
}
)
}
#initial state
state <- c(R = 100)
#define time sequence you want to run the model
times <- seq(0, 100,  by = 1)
# run simulation using continuous approach
out  <- ode(times = times, y = state,   parms = parameters, func = volume, method = "euler")
head(out)
plot(out)
